#!/usr/bin/env bash

subshell_wait()
{
    # assign arguments to variables
    FIFO=$1
    subshell_pids="${@:2}"
    
    # get subshell counts
    pid_count=${#subshell_pids[@]}
    total_pids=$pid_count
    
    # add an empty newline so that the previous line isn't deleted
    echo

    while [ $pid_count -gt 0 ] || [ -n "$subshell_output" ] ; do
        for (( i=0; i<pid_count; i++ )); do
            pid=${subshell_pids[$i]}
            if ! kill -0 $pid 2> /dev/null; then
                # process has finished, remove it from the array
                unset subshell_pids[$i]
            fi
        done
        subshell_pids=( ${subshell_pids[@]} )
        pid_count=${#subshell_pids[@]}

        # read the next line of output from the subprocesses from the $FIFO
        # store the line of output in the $subshell_output variable
        # `-t 1` to timeout if no output to read after 1 second
        # `|| true` to prevent the script from exiting if read returns an error code (due to timeout)
        read -t 1 subshell_output || true

        # if $subshell_output has a value
        if [ -n "${subshell_output}" ]; then  
            # delete the previous line in the terminal
            echo -en "\033[A\033[K"
            echo "$subshell_output"
            echo
        fi

        # calculate and print the progress
        pids_remaining=$(( total_pids - pid_count ))
        progress="$(( pids_remaining * 100 / total_pids ))%, pids remaining: (${pids_remaining}/${total_pids})"
        # delete the previous line in the terminal
        echo -en "\033[A\033[K"
        echo "Downloading and extracting codebases: ${progress}"

        # no sleep needed as the read will wait for 1 second if no output
    done <> $FIFO
}
